Добро пожаловать в документацию проекта bosk!
=============================================

*English version is located* :doc:`here <en_index>`.

Bosk (в переводе чаща леса) - это фреймворк для построения моделей
Глубоких лесов.

Опираясь на общеупотребимый способ описания моделей машинного обучения
в фреймворках, модели внутри bosk представляют из себя вычислительные графы
общего вида и не имеют строго определенной многослойной структуры.
В bosk каждая модель инкапсулирует в себе два различных вычислительных
графа: первый отвечает за стадию обучения модели, второй - предсказания.

Наш фреймворк позволяет разрабатывать новые архитектуры глубоких
лесов, не прибегая к написанию подверженного ошибкам монотонного рутинного кода,
а также содержит полезные инструменты для выполнения и отладки вычислительных графов.
Помимо этого, в bosk представлено большое количество готовых к использованию
стандартных исполнительных блоков.
Фреймворк поддерживает как ручное задание вычислительного графа Глубокого леса,
так и его автоматическое построение в формате слой за слоем.

Краткий пример
~~~~~~~~~~~~~~~

Пусть даны обучающие данные в виде `X_train` – матрицы размера N×M,
состоящей из N векторов признаков размерности M,
и вектора целевых значений  `y_train` размерности N, содержащего метки классов.
Также пусть дана матрица `X_test` размера K×M, содержащая K векторов признаков,
для которых необходимо предсказать вероятности классов.

Предположим, мы хотим создать однослойный Глубокий лес, содержащий в себе
два вида лесов: случайный лес (Random Forest) и модель сверхслучайных деревьев
(Extremely Randomized Trees). Вероятности, предсказанные обоими моделями,
будут сконкатенированы с вектором входных признаков и переданы в финальный
лес. Для того, чтобы определить описанную модель, можно предложить следующий код:

.. code-block:: python

    from bosk.pipeline.builder import FunctionalPipelineBuilder
    from bosk.executor import RecursiveExecutor, BoskPipelineClassifier

    # подключение блоков для обеспечения подсказок IDE
    from bosk.block.zoo.input_plugs import Input, TargetInput
    from bosk.block.zoo.data_conversion import Concat
    from bosk.block.zoo.models.classification import RFC, ETC
    from bosk.block.zoo.output_plugs import Output

    # создание построителя конвейера
    with FunctionalPipelineBuilder() as b:
        # блоки для маршрутизации входных данных:
        # `x` для вектора факторов и `y`
        # для откликов
        x = Input('X')()  # вход input-блока пустой
        y = TargetInput('y')()
        # блоки моделей лесов
        random_forest = RFC(max_depth=5)
        extra_trees = ETC(n_estimators=200)
        # блок конкатенации
        cat = Concat(['x', 'rf', 'et'])
        # слой, конкатенирующий выходные векторы лесов
        # и вектор входных признаков
        layer_1 = cat(x=x, rf=random_forest(X=x, y=y), et=extra_trees(X=x, y=y))
        # лес для осуществления итогового предсказания
        final_extra_trees = ETC()
        # выход конвейера
        Output('proba')(final_extra_trees(X=layer_1, y=y))

        # любой блок из `bosk.block.zoo` также доступен через построитель, без импорта:
        b.Output('alternative_proba')(b.XGBClassifier(max_depth=5)(X=layer_1, y=y))
        # данный блок не будет обучен по умолчанию, поскольку выход не используется для предсказаний

    # создание конвейера
    pipeline = b.build()

    # scikit-learn обертка для конвейера
    model = BoskPipelineClassifier(pipeline, executor_cls=RecursiveExecutor)
    # обучаем модель
    model.fit(X_train, y_train)
    # осуществляем предсказание
    test_preds = model.predict(X_test)


Больше примеров Вы можете найти :doc:`здесь <ru_getting_started>`.

Содержание
~~~~~~~~~~

.. toctree::
   :maxdepth: 1

   Инструкция по установке <ru_install>
   Вводная инструкция <ru_getting_started>
   Примеры <ru_examples>
   ru_contribution
   ru_autoapi_index
   English version <en_index>
