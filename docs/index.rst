Добро пожаловать в документацию проекта bosk!
=============================================

*English version is located* :doc:`here <en_index>`.

Bosk (в переводе чаща леса) - это фреймворк для построения моделей
Глубоких лесов.

Опираясь на общеупотребимый способ описания моделей машинного обучения
в фреймворках, модели внутри bosk представляют из себя вычислительные графы
общего вида и не имеют строго определенной многослойной структуры.
В bosk каждая модель инкапсулирует в себе два различных вычислительных
графа: первый отвечает за стадию обучения модели, второй - предсказания.

Наш фреймворк позволяет разрабатывать новые архитектуры глубоких
лесов, не прибегая к написанию подверженного ошибкам монотонного рутинного кода,
а также содержит полезные инструменты для выполнения и отладки вычислительных графов.
Помимо этого, в bosk представлено большое количество готовых к использованию
стандартных исполнительных блоков.
Фреймворк поддерживает как ручное задание вычислительного графа Глубокого леса,
так и его автоматическое построение в формате слой за слоем.

Краткий пример
~~~~~~~~~~~~~~~

Пусть даны обучающие данные в виде `X_train` – матрицы размера N×M, состоящей из N векторов признаков размерности M, и вектора целевых значений  `y_train` размерности N, содержащего метки классов.
Также пусть дана матрица `X_test` размера K×M, содержащая K векторов признаков, для которых необходимо предсказать вероятности классов.

Предположим, мы хотим создать однослойный Глубокий лес, содержащий в себе
два вида лесов: случайный лес (Random Forest) и модель сверхслучайных деревьев
(Extremely Randomized Trees). Вероятности, предсказанные обоими моделями,
будут сконкатенированы с вектором входных признаков и переданы в финальный
лес. Для того, чтобы определить описанную модель, можно предложить следующий код:

.. code-block:: python

   # создание построителя конвейера
   b = FunctionalPipelineBuilder()
   # блоки для маршрутизации входных данных:
   # `x` для вектора факторов и `y`
   # для откликов
   x = b.Input('x')()
   y = b.TargetInput('y')()
   # блоки моделей лесов
   random_forest = b.RFC(max_depth=5)
   extra_trees = b.ETC(n_estimators=200)
   # блок конкатенации
   cat = b.Concat(['x', 'rf', 'et'])
   # слой, конкатенирующий выходные векторы лесов
   # и вектор входных признаков
   layer_1 = cat(x=x, rf=rf(X=x, y=y), et=extra_trees(X=x, y=y))
   # лес для осуществления итогового предсказания
   final_extra_trees = b.ETC()
   # выход конвейера
   b.Output('proba')(final_extra_trees(X=layer_1, y=y))
   # создание конвейера
   pipeline = b.build()

   # scikit-learn обертка для конвейера
   model = BoskPipelineClassifier(pipeline, executor_cls=RecursiveExecutor)
   # обучаем модель
   model.fit(X_train, y_train)
   # осуществляем предсказание
   test_preds = model.predict(X_test)

Больше примеров Вы можете найти :doc:`здесь <ru_getting_started>`.

Содержание
~~~~~~~~~~

.. toctree::
   :maxdepth: 1

   Инструкция по установке <ru_install>
   Вводная инструкция <ru_getting_started>
   Примеры <ru_examples>
   ru_contribution
   ru_autoapi_index
   English version <en_index>
